# == Schema Information
#
# Table name: hub_notifications
#
#  id                :bigint           not null, primary key
#  dismissed_at      :datetime
#  displayed_at      :datetime
#  message           :text
#  metadata          :jsonb
#  notification_type :string
#  read_at           :datetime
#  url               :string
#  created_at        :datetime         not null
#  updated_at        :datetime         not null
#  user_id           :bigint           not null
#
# Indexes
#
#  index_hub_notifications_on_dismissed_at       (dismissed_at)
#  index_hub_notifications_on_displayed_at       (displayed_at)
#  index_hub_notifications_on_notification_type  (notification_type)
#  index_hub_notifications_on_read_at            (read_at)
#  index_hub_notifications_on_user_id            (user_id)
#
# Foreign Keys
#
#  fk_rails_...  (user_id => hub_admin_users.id)
#

# The Notification model represents a notification sent to a user.
# Notifications can be of different types (info, success, warning, error)
# and can have various states (read, dismissed, displayed).
#
# Notifications are created by the Hub::NotificationService and
# broadcast to users via Action Cable.
#
# This model follows Rails 8 best practices:
# - Using modern hash syntax for enums
# - Leveraging attribute-based type casting
# - Using Solid Cache for better performance
# - Taking advantage of enhanced JSON support for metadata
class Hub::Notification < ApplicationRecord
  # Use the constants from Notifiable concern for consistency
  NOTIFICATION_TYPES = Hub::Notifiable::NOTIFICATION_TYPES
  VALID_TYPES = NOTIFICATION_TYPES.values.freeze
  
  # Define enum for notification_type using modern Rails 8 hash syntax
  enum :notification_type, {
    info: NOTIFICATION_TYPES[:INFO],
    success: NOTIFICATION_TYPES[:SUCCESS],
    warning: NOTIFICATION_TYPES[:WARNING],
    error: NOTIFICATION_TYPES[:ERROR]
  }
  
  # jsonb column already has JSON serialization built-in
  # no need to add serialize as PostgreSQL handles this natively
  
  # Associations
  belongs_to :user, class_name: 'Hub::Admin::User'
  
  # Validations
  validates :notification_type, inclusion: { in: VALID_TYPES }
  validates :message, presence: true
  
  # Status scopes with Rails 8 enhanced querying
  scope :unread, -> { 
    where(read_at: nil).
    where('(notification_type = ? AND created_at > ?) OR 
           (notification_type = ? AND created_at > ?) OR 
           (notification_type = ? AND created_at > ?) OR 
           (notification_type = ? AND created_at > ?)',
          NOTIFICATION_TYPES[:INFO], 1.minute.ago,
          NOTIFICATION_TYPES[:SUCCESS], 1.minute.ago,
          NOTIFICATION_TYPES[:WARNING], 5.minutes.ago,
          NOTIFICATION_TYPES[:ERROR], 1.hour.ago)
  }
  scope :undismissed, -> { where(dismissed_at: nil) }
  scope :recent, -> { order(created_at: :desc) }
  scope :not_displayed, -> { where(displayed_at: nil) }
  scope :for_user, ->(user_id) { where(user_id: user_id) }
  scope :created_between, ->(start_date, end_date) { where(created_at: start_date..end_date) }
  scope :with_metadata_containing, ->(key, value) { where("metadata->>'#{key}' = ?", value.to_s) }
  
  # Scope for auto-expired notifications based on type and time
  scope :auto_expired, -> {
    where(read_at: nil).
    where('(notification_type = ? AND created_at <= ?) OR 
           (notification_type = ? AND created_at <= ?) OR 
           (notification_type = ? AND created_at <= ?) OR 
           (notification_type = ? AND created_at <= ?)',
          NOTIFICATION_TYPES[:INFO], 1.minute.ago,
          NOTIFICATION_TYPES[:SUCCESS], 1.minute.ago,
          NOTIFICATION_TYPES[:WARNING], 5.minutes.ago,
          NOTIFICATION_TYPES[:ERROR], 1.hour.ago)
  }
  
  # Type scopes - these are now auto-generated by the enum definition above
  # so we don't need to define them manually. Rails 8 automatically creates:
  # scope :info, -> { where(notification_type: 'info') }
  # scope :success, -> { where(notification_type: 'success') }
  # scope :warning, -> { where(notification_type: 'warning') }
  # scope :error, -> { where(notification_type: 'error') }
  
  # Instance methods for state changes
  
  # Marks the notification as read
  # @return [Boolean] true if the notification was marked as read, false otherwise
  def mark_as_read!
    # Using Rails 8's improved touch with custom attribute
    touch(:read_at) if read_at.nil?
    # Invalidate relevant cache entries
    invalidate_user_cache
  end
  
  # Dismisses the notification
  # @return [Boolean] true if the notification was dismissed, false otherwise
  def dismiss!
    # Using Rails 8's improved touch with custom attribute
    touch(:dismissed_at) if dismissed_at.nil?
    # Invalidate relevant cache entries
    invalidate_user_cache
  end
  
  # Marks the notification as displayed to the user
  # @return [Boolean] true if the notification was marked as displayed, false otherwise
  def mark_as_displayed!
    # Using Rails 8's improved touch with custom attribute
    touch(:displayed_at) if displayed_at.nil?
  end
  
  # Invalidate user-related cache entries
  # Used when notification states change
  private def invalidate_user_cache
    Rails.cache.delete("user_#{user_id}_unread_count")
  end
  
  # Check if notification is read
  # @return [Boolean] true if the notification has been read
  def read?
    read_at.present?
  end
  
  # Check if notification is dismissed
  # @return [Boolean] true if the notification has been dismissed
  def dismissed?
    dismissed_at.present?
  end
  
  # Check if notification has been displayed
  # @return [Boolean] true if the notification has been displayed
  def displayed?
    displayed_at.present?
  end
end
